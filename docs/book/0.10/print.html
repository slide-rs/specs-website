<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Rendering - The Specs Book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Introduction into ECS and the Specs API.">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="01_intro.html"><strong>1.</strong> Introduction</a></li><li><a href="02_hello_world.html"><strong>2.</strong> Hello World</a></li><li><a href="03_dispatcher.html"><strong>3.</strong> Dispatcher</a></li><li><a href="04_resources.html"><strong>4.</strong> Resources</a></li><li><a href="05_storages.html"><strong>5.</strong> Storages</a></li><li><a href="06_system_data.html"><strong>6.</strong> System Data</a></li><li><a href="07_parallel_join.html"><strong>7.</strong> Parallel Join</a></li><li><a href="08_rendering.html"><strong>8.</strong> Rendering</a></li><li><strong>9.</strong> Building a game with Specs</li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Specs Book</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#introduction" id="introduction"><h1>Introduction</h1></a>
<p>Welcome to The Specs Book, an introduction to ECS and the Specs API.
This book is targeted at beginners; guiding you through all the difficulties of
setting up, building, and structuring a game with an ECS.</p>
<p>Specs is an ECS library that allows parallel system execution, with both low
overhead and high flexibility, different storage types and a type-level
system data model.</p>
<p>You didn't fully understand what that sentence was about? The next section
is for you! In case you already know what an ECS is, just skip it.</p>
<a class="header" href="print.html#whats-an-ecs" id="whats-an-ecs"><h2>What's an ECS?</h2></a>
<p>The term <strong>ECS</strong> is a shorthand for Entity-component system. These are the three
core concepts. Each <strong>entity</strong> is associated with some <strong>components</strong>. Those entities and
components are processed by <strong>systems</strong>. This way, you have your data (components)
completely separated from the behaviour (systems). An entity just logically
groups components; so a <code>Velocity</code> component can be applied to the <code>Position</code> component
of the same entity.</p>
<p>ECS is sometimes seen as a counterpart to Object-Oriented Programming. I wouldn't
say that's one hundred percent true, but let me give you some comparisons.</p>
<p>In OOP, your player might look like this (I've used Java for the example):</p>
<pre><code class="language-java">public class Player extends Character {
    private final Transform transform;
    private final Inventory inventory;
}
</code></pre>
<p>There are several limitations here:</p>
<ul>
<li>There is either no multiple inheritance or it brings other problems with it,
like <a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">the diamond problem</a>; moreover, you have to think about &quot;<em>is</em> the player
a collider or does it <em>have</em> a collider?&quot;</li>
<li>You cannot easily extend the player with modding; all the attributes are hardcoded.</li>
<li>Imagine you want to add a NPC, which looks like this:</li>
</ul>
<pre><code class="language-java">public class Npc extends Character {
    private final Transform transform;
    private final Inventory inventory;
    private final boolean isFriendly;
}
</code></pre>
<p>Now you have stuff duplicated; you would have to write mostly identical code for
your player and the NPC, even though e.g. they both share a transform.</p>
<p>This is where the ECS comes into play: Components are <em>associated</em> with entities;
you just insert some component, whenever you like. Also, you only define the functionality
once: One System, taking a <code>Force</code> and a <code>Mass</code> - it produces a <code>Velocity</code>.</p>
<p>In fact, an entity does not even own the components; it's just</p>
<pre><code class="language-rust ignore">struct Entity(u32, Generation);
</code></pre>
<p>where the first field is the id and the second one is the generation, used to validate
if the entity hasn't been deleted. The components are stored separately, which
also has the advantage of being more cache efficient.</p>
<p>Another way you can think of an entity is that it just
groups together a group of components. We'll see how this works
in practice later - it allows us to just pick sets of components
which include both <code>A</code> and <code>B</code>.</p>
<a class="header" href="print.html#where-to-use-an-ecs" id="where-to-use-an-ecs"><h2>Where to use an ECS?</h2></a>
<p>In case you were looking for a general-purpose library for doing it
the data-oriented way, I have to disappoint you; there is none.
ECS libraries are best-suited for creating games; in fact, I've never
heard of anybody using an ECS for something else.</p>
<hr />
<p>Okay, now that you were given a rough overview, let's continue
to <a href="./02_hello_world.html">Chapter 2</a> where we'll build our first actual application with Specs.</p>
<a class="header" href="print.html#hello-world" id="hello-world"><h1>Hello, <code>World</code>!</h1></a>
<a class="header" href="print.html#setting-up" id="setting-up"><h2>Setting up</h2></a>
<p>First of all, thanks for trying out <code>specs</code>. Let's
set it up first. Add the following line to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">specs = &quot;0.10&quot;
</code></pre>
<p>And add this to your crate root (<code>main.rs</code> or <code>lib.rs</code>):</p>
<pre><code class="language-rust ignore">extern crate specs;
</code></pre>
<a class="header" href="print.html#components" id="components"><h2>Components</h2></a>
<p>Let's start by creating some data:</p>
<pre><code class="language-rust ignore">use specs::{Component, VecStorage};

#[derive(Debug)]
struct Position {
    x: f32,
    y: f32
}

impl Component for Position {
    type Storage = VecStorage&lt;Self&gt;;
}

#[derive(Debug)]
struct Velocity {
    x: f32,
    y: f32,
}

impl Component for Velocity {
    type Storage = VecStorage&lt;Self&gt;;
}
</code></pre>
<p>These will be our two component types. Optionally, the <code>specs-derive</code> crate
provides a convenient custom <code>#[derive]</code> you can use to define component types
more succinctly:</p>
<pre><code class="language-rust ignore">#[derive(Component, Debug)]
#[component(VecStorage)]
struct Position {
    x: f32,
    y: f32
}

#[derive(Component, Debug)]
#[component(VecStorage)]
struct Velocity {
    x: f32,
    y: f32,
}
</code></pre>
<p>If the <code>#[component(...)]</code> attribute is omitted, the given component will be
stored in a <code>DenseVecStorage</code> by default. But for this example, we are
explicitly asking for these components to be kept in a <code>VecStorage</code> instead (see
the later <a href="./05_storages.html">storages chapter</a> for more details). But before we move on, we
need to create a world in which to store all of our components.</p>
<a class="header" href="print.html#the-world" id="the-world"><h2>The <code>World</code></h2></a>
<pre><code class="language-rust ignore">use specs::World;

let mut world = World::new();
world.register::&lt;Position&gt;();
</code></pre>
<p>This will create a component storage for <code>Position</code>s.</p>
<pre><code class="language-rust ignore">let ball = world.create_entity().with(Position { x: 4.0, y: 7.0 }).build();
</code></pre>
<p>Now you have an <code>Entity</code>, associated with a position.</p>
<p>So far this is pretty boring. We just have some data,
but we don't do anything with it. Let's change that!</p>
<a class="header" href="print.html#the-system" id="the-system"><h2>The system</h2></a>
<pre><code class="language-rust ignore">use specs::System;

struct HelloWorld;

impl&lt;'a&gt; System&lt;'a&gt; for HelloWorld {
    type SystemData = ();

    fn run(&amp;mut self, data: Self::SystemData) {}
}
</code></pre>
<p>This is what a system looks like. Though it doesn't do anything (yet).
Let's talk about this dummy implementation first.
The <code>SystemData</code> is an associated type
which specifies which components we need in order to run
the system.</p>
<p>Let's see how we can read our <code>Position</code> components:</p>
<pre><code class="language-rust ignore">use specs::{ReadStorage, System};

struct HelloWorld;

impl&lt;'a&gt; System&lt;'a&gt; for HelloWorld {
    type SystemData = ReadStorage&lt;'a, Position&gt;;

    fn run(&amp;mut self, position: Self::SystemData) {
        use specs::Join;

        for position in position.join() {
            println!(&quot;Hello, {:?}&quot;, &amp;position);
        }
    }
}
</code></pre>
<p>Note that all components that a system accesses must be registered with
<code>world.register::&lt;Component&gt;()</code> before that system is run, or you will get a
panic.</p>
<blockquote>
<p>There are many other types you can use as system data. Please see the
<a href="./06_system_data.html">System Data Chapter</a> for more information.</p>
</blockquote>
<a class="header" href="print.html#running-the-system" id="running-the-system"><h2>Running the system</h2></a>
<p>This just iterates through all the components and prints
them. To execute the system, you can use <code>RunNow</code> like this:</p>
<pre><code class="language-rust ignore">use specs::RunNow;

let mut hello_world = HelloWorld;
hello_world.run_now(&amp;world.res);
</code></pre>
<a class="header" href="print.html#full-example-code" id="full-example-code"><h2>Full example code</h2></a>
<p>Here the complete example of this chapter:</p>
<pre><code class="language-rust ignore">use specs::{Component, ReadStorage, System, VecStorage, World, RunNow};

#[derive(Debug)]
struct Position {
    x: f32,
    y: f32
}

impl Component for Position {
    type Storage = VecStorage&lt;Self&gt;;
}

#[derive(Debug)]
struct Velocity {
    x: f32,
    y: f32,
}

impl Component for Velocity {
    type Storage = VecStorage&lt;Self&gt;;
}

struct HelloWorld;

impl&lt;'a&gt; System&lt;'a&gt; for HelloWorld {
    type SystemData = ReadStorage&lt;'a, Position&gt;;

    fn run(&amp;mut self, position: Self::SystemData) {
        use specs::Join;

        for position in position.join() {
            println!(&quot;Hello, {:?}&quot;, &amp;position);
        }
    }
}

fn main() {
    let mut world = World::new();
    world.register::&lt;Position&gt;();

    world.create_entity().with(Position { x: 4.0, y: 7.0 }).build();

    let mut hello_world = HelloWorld;
    hello_world.run_now(&amp;world.res);
}
</code></pre>
<hr />
<p>This was a pretty basic example so far. A key feature we haven't seen is the
<code>Dispatcher</code>, which allows to configure run systems in parallel (and it offers
some other nice features, too).</p>
<p>Let's see how that works in <a href="./03_dispatcher.html">Chapter 3: Dispatcher</a>.</p>
<a class="header" href="print.html#dispatcher" id="dispatcher"><h1>Dispatcher</h1></a>
<a class="header" href="print.html#when-to-use-a-dispatcher" id="when-to-use-a-dispatcher"><h2>When to use a <code>Dispatcher</code></h2></a>
<p>The <code>Dispatcher</code> allows you to automatically parallelize
system execution where possible, using the <a href="https://en.wikipedia.org/wiki/Fork%E2%80%93join_model">fork-join model</a> to split up the
work and merge the result at the end. It requires a bit more planning
and may have a little bit more overhead, but it's pretty convenient,
especially when you're building a big game where you don't
want to do this manually.</p>
<a class="header" href="print.html#building-a-dispatcher" id="building-a-dispatcher"><h2>Building a dispatcher</h2></a>
<p>First of all, we have to build such a dispatcher.</p>
<pre><code class="language-rust ignore">use specs::DispatcherBuilder;

let mut dispatcher = DispatcherBuilder::new()
    .add(hello_world, &quot;hello_world&quot;, &amp;[])
    .build();
</code></pre>
<p>Let's see what this does. After creating the builder,
we add a new</p>
<ol>
<li>system object (<code>hello_world</code>)</li>
<li>with some name (<code>&quot;hello_world&quot;&quot;</code>)</li>
<li>and no dependencies (<code>&amp;[]</code>).</li>
</ol>
<p>The name can be used to specify that system
as a dependency of another one. But we don't have a second
system yet.</p>
<a class="header" href="print.html#creating-another-system" id="creating-another-system"><h2>Creating another system</h2></a>
<pre><code class="language-rust ignore">struct UpdatePos;

impl&lt;'a&gt; System&lt;'a&gt; for UpdatePos {
    type SystemData = (ReadStorage&lt;'a, Velocity&gt;,
                       WriteStorage&lt;'a, Position&gt;);
}
</code></pre>
<p>Let's talk about the system data first. What you see here
is a <strong>tuple</strong>, which we are using as our <code>SystemData</code>.
In fact, <code>SystemData</code> is implemented for all tuples
with up to 26 other types implementing <code>SystemData</code> in it.</p>
<blockquote>
<p>Notice that <code>ReadStorage</code> and <code>WriteStorage</code> <em>are</em> implementors of <code>SystemData</code>
themselves, that's why we could use the first one for our <code>HelloWorld</code> system
without wrapping it in a tuple; for more information see
<a href="./06_system_data.html">the Chapter about system data</a>.</p>
</blockquote>
<p>To complete the implementation block, here's the <code>run</code> method:</p>
<pre><code class="language-rust ignore">    fn run(&amp;mut self, (vel, mut pos): Self::SystemData) {
        use specs::Join;
        for (vel, pos) in (&amp;vel, &amp;mut pos).join() {
            pos.x += vel.x * 0.05;
            pos.y += vel.y * 0.05;
        }
    }
</code></pre>
<p>Now the <code>.join()</code> method also makes sense: it joins the two component
storages, so that you either get no new element or a new element with
both components, meaning that entities with only a <code>Position</code>, only
a <code>Velocity</code> or none of them will be skipped. The <code>0.05</code> fakes the
so called <strong>delta time</strong> which is the time needed for one frame.
We have to hardcode it right now, because it's not a component (it's the
same for every entity). The solution to this are <code>Resource</code>s, see
<a href="./04_resources.html">the next Chapter</a>.</p>
<a class="header" href="print.html#adding-a-system-with-a-dependency" id="adding-a-system-with-a-dependency"><h2>Adding a system with a dependency</h2></a>
<p>Okay, now you can add another system <em>after</em> the <code>HelloWorld</code> system:</p>
<pre><code class="language-rust ignore">    .add(UpdatePos, &quot;update_pos&quot;, &amp;[&quot;hello_world&quot;])
</code></pre>
<p>The <code>UpdatePos</code> system now depends on the <code>HelloWorld</code> system and will only
be executed after the dependency has finished.</p>
<p>Now to execute all the systems, just do</p>
<pre><code class="language-rust ignore">dispatcher.dispatch(&amp;mut world.res);
</code></pre>
<a class="header" href="print.html#full-example-code-1" id="full-example-code-1"><h2>Full example code</h2></a>
<p>Here the code for this chapter:</p>
<pre><code class="language-rust ignore">use specs::{Component, DispatcherBuilder, ReadStorage,
            System, VecStorage, World, WriteStorage};

#[derive(Debug)]
struct Position {
    x: f32,
    y: f32
}

impl Component for Position {
    type Storage = VecStorage&lt;Self&gt;;
}

#[derive(Debug)]
struct Velocity {
    x: f32,
    y: f32,
}

impl Component for Velocity {
    type Storage = VecStorage&lt;Self&gt;;
}

struct HelloWorld;

impl&lt;'a&gt; System&lt;'a&gt; for HelloWorld {
    type SystemData = ReadStorage&lt;'a, Position&gt;;

    fn run(&amp;mut self, position: Self::SystemData) {
        use specs::Join;

        for position in position.join() {
            println!(&quot;Hello, {:?}&quot;, &amp;position);
        }
    }
}

struct UpdatePos;

impl&lt;'a&gt; System&lt;'a&gt; for UpdatePos {
    type SystemData = (ReadStorage&lt;'a, Velocity&gt;,
                       WriteStorage&lt;'a, Position&gt;);

    fn run(&amp;mut self, (vel, mut pos): Self::SystemData) {
        use specs::Join;
        for (vel, pos) in (&amp;vel, &amp;mut pos).join() {
            pos.x += vel.x * 0.05;
            pos.y += vel.y * 0.05;
        }
    }
}

fn main() {
    let mut world = World::new();
    world.register::&lt;Position&gt;();
    world.register::&lt;Velocity&gt;();

    // Only the second entity will get a position update,
    // because the first one does not have a velocity.
    world.create_entity().with(Position { x: 4.0, y: 7.0 }).build();
    world
        .create_entity()
        .with(Position { x: 2.0, y: 5.0 })
        .with(Velocity { x: 0.1, y: 0.2 })
        .build();

    let mut dispatcher = DispatcherBuilder::new()
        .add(HelloWorld, &quot;hello_world&quot;, &amp;[])
        .add(UpdatePos, &quot;update_pos&quot;, &amp;[&quot;hello_world&quot;])
        .build();

    dispatcher.dispatch(&amp;mut world.res);
}
</code></pre>
<hr />
<p><a href="./04_resources.html">The next chapter</a> will be a really short chapter about <code>Resource</code>s,
a way to share data between systems which do only exist independent of
entities (as opposed to 0..1 times per entity).</p>
<a class="header" href="print.html#resources" id="resources"><h1>Resources</h1></a>
<p>This (short) chapter will explain the concept of resources, data
which is shared between systems.</p>
<p>First of all, when would you need resources? There's actually a great
example in <a href="./03_dispatcher.html">chapter 3</a>, where we just faked the delta time when applying
the velocity. Let's see how we can do this the right way.</p>
<pre><code class="language-rust ignore">struct DeltaTime(f32);
</code></pre>
<blockquote>
<p><strong>Note:</strong> In practice you may want to use <code>std::time::Duration</code> instead,
because you shouldn't use <code>f32</code>s for durations in an actual game, because
they're not precise enough.</p>
</blockquote>
<p>Adding this resource to our world is pretty easy:</p>
<pre><code class="language-rust ignore">world.add_resource(DeltaTime(0.05)); // Let's use some start value
</code></pre>
<p>To update the delta time, just use</p>
<pre><code class="language-rust ignore">let delta = world.write_resource::&lt;DeltaTime&gt;();
*delta = DeltaTime(0.04);
</code></pre>
<a class="header" href="print.html#accessing-resources-from-a-system" id="accessing-resources-from-a-system"><h2>Accessing resources from a system</h2></a>
<p>As you might have guessed, there's a type implementing system data
specifically for resources. It's called <code>Fetch</code> (or <code>FetchMut</code> for
write access).</p>
<p>So we can now rewrite our system:</p>
<pre><code class="language-rust ignore">use specs::{Fetch, ReadStorage, System, WriteStorage};

struct UpdatePos;

impl&lt;'a&gt; System&lt;'a&gt; for UpdatePos {
    type SystemData = (Fetch&lt;'a, DeltaTime&gt;,
                       ReadStorage&lt;'a, Velocity&gt;,
                       WriteStorage&lt;'a, Position&gt;);

    fn run(&amp;mut self, data: Self::SystemData) {
        let (delta, vel, mut pos) = data;

        // `Fetch` implements `Deref`, so it
        // coerces to `&amp;DeltaTime`.
        let delta = delta.0;

        for (vel, pos) in (&amp;vel, &amp;mut pos).join() {
            pos.x += vel.x * delta;
            pos.y += vel.y * delta;
        }
    }
}
</code></pre>
<p>Note that all resources that a system accesses must be registered with
<code>world.add_resource(resource)</code> before that system is run, or you will get a
panic.</p>
<p>For more information on <code>SystemData</code>, see <a href="./06_system_data.html">the system data chapter</a>.</p>
<hr />
<p>In <a href="05_storages.html">the next chapter</a>, you will learn about the different storages
and when to use which one.</p>
<a class="header" href="print.html#storages" id="storages"><h1>Storages</h1></a>
<p>Specs contains a bunch of different storages, all built and optimized for
different use cases. But let's see some basics first.</p>
<a class="header" href="print.html#storage-basics" id="storage-basics"><h2>Storage basics</h2></a>
<p>What you specify in a component <code>impl</code>-block is an <code>UnprotectedStorage</code>.
Each <code>UnprotectedStorage</code> exposes an unsafe getter which does not
perform any checks whether the requested index for the component is valid
(the id of an entity is the index of its component). To allow checking them
and speeding up iteration, we have something called hierarchical bitsets,
provided by <a href="https://github.com/slide-rs/hibitset"><code>hibitset</code></a>.</p>
<blockquote>
<p><strong>Note:</strong> In case you don't know anything about bitsets,
you can safely skip the following section about it. Just keep
in mind that we have some mask which tracks for
which entities a component exists.</p>
</blockquote>
<p>How does it speed up the iteration? A hierarchical bitset is essentially
a multi-layer bitset, where each upper layer &quot;summarizes&quot; multiple bits
of the underlying layers. That means as soon as one of the underlying
bits is <code>1</code>, the upper one also becomes <code>1</code>, so that we can skip a whole
range of indices if an upper bit is <code>0</code> in that section. In case it's <code>1</code>,
we go down by one layer and perform the same steps again (it currently
has 4 layers).</p>
<a class="header" href="print.html#storage-overview" id="storage-overview"><h2>Storage overview</h2></a>
<p>Here a list of the storages with a short description and a link
to the corresponding heading.</p>
<table><thead><tr><th align="center">Storage Type         </th><th>Description               </th><th>Optimized for                 </th></tr></thead><tbody>
<tr><td align="center"> <a href="print.html#btreestorage"><code>BTreeStorage</code></a>    </td><td> Works with a <code>BTreeMap</code>  </td><td> no particular case           </td></tr>
<tr><td align="center"> <a href="print.html#densevecstorage"><code>DenseVecStorage</code></a> </td><td> Uses a redirection table </td><td> fairly often used components </td></tr>
<tr><td align="center"> <a href="print.html#hashmapstorage"><code>HashMapStorage</code></a>  </td><td> Uses a <code>HashMap</code>         </td><td> rare components              </td></tr>
<tr><td align="center"> <a href="print.html#nullstorage"><code>NullStorage</code></a>     </td><td> Can flag entities        </td><td> doesn't depend on rarity     </td></tr>
<tr><td align="center"> <a href="print.html#vecstorage"><code>VecStorage</code></a>      </td><td> Uses a sparse <code>Vec</code>      </td><td> commonly used components     </td></tr>
</tbody></table>
<a class="header" href="print.html#btreestorage" id="btreestorage"><h2><code>BTreeStorage</code></h2></a>
<p>It works using a <code>BTreeMap</code> and it's meant to be the default storage
in case you're not sure which one to pick, because it fits all scenarios
fairly well.</p>
<a class="header" href="print.html#densevecstorage" id="densevecstorage"><h2><code>DenseVecStorage</code></h2></a>
<p>This storage uses two <code>Vec</code>s, one containing the actual data and the other
one which provides a mapping from the entity id to the index for the data vec
(it's a redirection table). This is useful when your component is bigger
than a <code>usize</code> because it consumes less RAM.</p>
<a class="header" href="print.html#hashmapstorage" id="hashmapstorage"><h2><code>HashMapStorage</code></h2></a>
<p>This should be used for components which are associated to very few entities,
because it provides a lower insertion cost and is packed together more tightly.
You should not use it for frequently used components, because the hashing cost would definitely
be noticeable.</p>
<a class="header" href="print.html#nullstorage" id="nullstorage"><h2><code>NullStorage</code></h2></a>
<p>As already described in the overview, the <code>NullStorage</code> does itself
only contain a user-defined ZST (=Zero Sized Type; a struct with no data in it,
like <code>struct Synced;</code>).
Because it's wrapped in a so-called <code>MaskedStorage</code>, insertions and deletions
modify the mask, so it can be used for flagging entities (like in this example
for marking an entity as <code>Synced</code>, which could be used to only synchronize
some of the entities over the network).</p>
<a class="header" href="print.html#vecstorage" id="vecstorage"><h2><code>VecStorage</code></h2></a>
<p>This one has only one vector (as opposed to the <code>DenseVecStorage</code>). It
just leaves uninitialized gaps where we don't have any component.
Therefore it would be a waste of memory to use this storage for
rare components, but it's best suited for commonly used components
(like transform values).</p>
<a class="header" href="print.html#rudystorage-experimental" id="rudystorage-experimental"><h2><code>RudyStorage</code> (Experimental)</h2></a>
<p>There is an experimental <code>RudyStorage</code>, which can be enabled with the <code>rudy</code> feature
flag. It uses <a href="https://crates.io/crates/rudy">the <code>rudy</code> crate</a>, the Rust implementation of <a href="http://judy.sourceforge.net">Judy Arrays</a>.</p>
<p>Its benefits are not clear yet.</p>
<a class="header" href="print.html#draft-system-data" id="draft-system-data"><h1>[DRAFT] System Data</h1></a>
<a class="header" href="print.html#accessing-entities" id="accessing-entities"><h2>Accessing Entities</h2></a>
<p>You want to create/delete entities from a system? There is
good news for you. You can just use <code>Entities</code> to do that.
It implements <code>SystemData</code> so just put it in your <code>SystemData</code> tuple.</p>
<blockquote>
<p>Don't confuse <code>specs::Entities</code> with <code>specs::EntitiesRes</code>.
While the latter one is the actual resource, the other one is a type
definition for <code>Fetch&lt;entity::Entities&gt;</code>.</p>
</blockquote>
<p>Please note that you may never write to these <code>Entities</code>, so only
use <code>Fetch</code>. Even though it's immutable, you can atomically create
and delete entities with it. Just use the <code>.create()</code> and <code>.delete()</code>
methods, respectively. After dynamic entity creation / deletion,
a call <code>World::maintain</code> is necessary in order to make the changes
persistent and delete associated components.</p>
<a class="header" href="print.html#adding-and-removing-components" id="adding-and-removing-components"><h2>Adding and removing components</h2></a>
<p>Adding or removing components can be done by modifying
either components storage directly with a <code>WriteStorage</code>
or lazily using the <code>LazyUpdate</code> resource.</p>
<pre><code class="language-rust ignore">use specs::{Component, Fetch, LazyUpdate, NullStorage, System, Entities, WriteStorage};

struct Stone;
impl Component for Stone {
    type Storage = NullStorage&lt;Self&gt;;
}

struct StoneCreator;
impl&lt;'a&gt; System&lt;'a&gt; for StoneCreator {
    type SystemData = (
        Entities&lt;'a&gt;,
        WriteStorage&lt;'a, Stone&gt;,
        Fetch&lt;'a, LazyUpdate&gt;
    );

    fn run(&amp;mut self, (entities, stones, updater): Self::SystemData) {
        let stone = entities.create();

        // 1) Either we insert the component by writing to its storage
        stones.insert(stone, Stone);

        // 2) or we can lazily insert it with `LazyUpdate`
        updater.insert(stone, Stone);
    }
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> After using <code>LazyUpdate</code> a call to <code>World::maintain</code>
is necessary to actually execute the changes.</p>
</blockquote>
<a class="header" href="print.html#draft-parallel-join" id="draft-parallel-join"><h1>[DRAFT] Parallel Join</h1></a>
<p>As mentioned in the chapter dedicated on how to <a href="./03_dispatcher.html">dispatch</a> systems,
Specs automatically parallelizes system execution when there is non-conflicting
component requirements between them (mutability XOR aliasing).</p>
<p>What isn't automatically parallelized by Specs are
the joins made within a single system:</p>
<pre><code class="language-rust ignore">    fn run(&amp;mut self, (vel, mut pos): Self::SystemData) {
        use specs::Join;
        // This loop runs sequentially on a single thread.
        for (vel, pos) in (&amp;vel, &amp;mut pos).join() {
            pos.x += vel.x * 0.05;
            pos.y += vel.y * 0.05;
        }
    }
</code></pre>
<p>This means that, if there are hundreds of thousands of entities and only few
systems that actually can be executed in parallel, then the full power
of CPU cores cannot be fully utilized.</p>
<p>To fix this inefficiency and to parallelize the joining, the <code>join</code>
method call can be exchanged for <code>par_join</code>:</p>
<pre><code class="language-rust ignore">    fn run(&amp;mut self, (vel, mut pos): Self::SystemData) {
        use specs::ParJoin;
        use rayon::iter::ParallelIterator;

        // Parallel joining behaves similarly to normal joining
        // with the difference that iteration can potentially be
        // executed in parallel by a thread pool—the same way as
        // the systems are executed.
        (&amp;vel, &amp;mut pos).par_join()
            .for_each(|(vel, pos)| {
                pos.x += vel.x * 0.05;
                pos.y += vel.y * 0.05;
            });
    }
</code></pre>
<p>The <code>par_join</code> method produces a type implementing <a href="https://crates.io/crates/rayon"><code>rayon</code>s <code>ParallelIterator</code></a>
trait which provides lots of helper methods to manipulate the iteration,
the same way as the normal <code>Iterator</code> trait does.</p>
<a class="header" href="print.html#rendering" id="rendering"><h1>Rendering</h1></a>
<p>Rendering is often a little bit tricky when you're dealing with a multi-threaded ECS.
That's why we have something called &quot;thread-local systems&quot;.</p>
<p>There are two things to keep in mind about thread-local systems:</p>
<ol>
<li>They're always executed at the end of dispatch</li>
<li>They cannot have dependencies, you just add them in the order you want them to run</li>
</ol>
<p>Adding one is a simple line added to the builder code:</p>
<pre><code class="language-rust ignore">DispatcherBuilder::new()
    .add_thread_local(RenderSys);
</code></pre>
<a class="header" href="print.html#amethyst" id="amethyst"><h2>Amethyst</h2></a>
<p>As for Amethyst, it's very easy because Specs is already integrated. So there's no special effort
required, just look at the current examples.</p>
<a class="header" href="print.html#piston" id="piston"><h2>Piston</h2></a>
<p>Piston has an event loop which looks like this:</p>
<pre><code class="language-rust ignore">while let Some(event) = window.poll_event() {
    // Handle event
}
</code></pre>
<p>Now, we'd like to do as much as possible in the ECS, so we feed in input as a
<a href="./04_resources.html">resource</a>.
This is what your code could look like:</p>
<pre><code class="language-rust ignore">struct ResizeEvents(Vec&lt;(u32, u32)&gt;);

world.add_resource(ResizeEvents(Vec::new()));

while let Some(event) = window.poll_event() {
    match event {
        Input::Resize(x, y) =&gt; world.write_resource::&lt;ResizeEvents&gt;().0.push((x, y)),
        // ...
    }
}
</code></pre>
<p>The actual dispatching should happen every time the <code>Input::Update</code> event occurs.</p>
<hr />
<blockquote>
<p>If you want a section for your game engine added, feel free to submit a PR!</p>
</blockquote>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        


        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
